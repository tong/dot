#%[ "$LF_LEVEL" -eq 1 ] || echo "WARNING: You're in a nested lf instance!"

#set drawbox
#set number
#set promptfmt "\033[32;1m%u@%h\033[0m:\033[34;1m%d\033[0m\033[1m%f\033[0m"
#set relativenumber
set colors
set hiddenfiles ".*:*.aux:*.log:*.bbl:*.bcf:*.blg:*.run.xml"
set icons
set ifs "\n"
set info size:time
set ratios '1:2:3'
set scrolloff 10
set shell sh
set shellopts '-eu'
set cleaner '~/.config/lf/cleaner'
set previewer '~/.config/lf/preview'

cmd bookmark-jump ${{
    res="$(cat $LF_BOOKMARK_PATH/$(ls $LF_BOOKMARK_PATH | fzf))"
    lf -remote "send $id cd \"$res\""
}}

cmd bookmark-create ${{
    read ans
    echo $PWD > $LF_BOOKMARK_PATH/$ans
}}

cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    if [ -n "$fs" ]; then
        fs="$(basename -a $fs)"
    else
        fs="$(ls)"
    fi
    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    $EDITOR "$new"
    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
    paste "$old" "$new" | while IFS= read -r names; do
        src="$(printf '%s' "$names" | cut -f1)"
        dst="$(printf '%s' "$names" | cut -f2)"
        if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
            continue
        fi
        mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}

#cmd copyto ${{
	#clear; tput cup $(($(tput lines)/3)); tput bold
	#set -f
	#clear; echo "Copy to where?"
	#dest="$(sed -e 's/\s*#.*//' -e '/^$/d' -e 's/^\S*\s*//' ${XDG_CONFIG_HOME:-$HOME/.config}/shell/bm-dirs | fzf | sed 's|~|$HOME|')" &&
	#for x in $fx; do
		#eval cp -ivr \"$x\" \"$dest\"
	#done &&
	#notify-send "ðŸ“‹ File(s) copied." "File(s) copies to $dest."
#}}

cmd extract ${{
    set -f
    extract $f
    outname=$(echo "$f" | cut -f 1 -d '.')
    notify-send --app-name='archive extracted' --urgency "low" --icon="$VOID/void-icons/actions/extract-archive.svg" "$f ï•“ $outname"
}}

# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        # symbolically copy mode is indicating a soft link
        copy) ln -sr -t . -- "$@";;
        # while a move mode is indicating a hard link
        move) ln -t . -- "$@";;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
}}

cmd mkdir %{{
    IFS=" "
    mkdir -p -- "$*"
    lf -remote "send $id select \"$*\""
}}

#cmd moveto ${{
	#clear; tput cup $(($(tput lines)/3)); tput bold
	#set -f
	#clear; echo "Move to where?"
	#dest="$(sed -e 's/\s*#.*//' -e '/^$/d' -e 's/^\S*\s*//' ${XDG_CONFIG_HOME:-$HOME/.config}/shell/bm-dirs | fzf | sed 's|~|$HOME|')" &&
	#for x in $fx; do
		#eval mv -iv \"$x\" \"$dest\"
	#done &&
	#notify-send "ðŸšš File(s) moved." "File(s) moved to $dest."
#}}

cmd mp3-convert ${{
    set -f
	outname=$(echo "$f" | cut -f 1 -d '.')
	lame -V --preset standard $f "${outname}.mp3"
}}

cmd open ${{
    test -L $f && f=$(readlink -f $f)
    case $(file --mime-type $f -b) in
        audio/*) mpv --audio-display=no $f ;;
        video/*) setsid -f mpv $f -quiet >/dev/null 2>&1 ;;
        image/x-xcf) setsid -f gimp $f >/dev/null 2>&1 ;;
        text/*|application/json) $EDITOR $fx;;
        *) for f in $fx; do setsid $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}

cmd on-cd &{{
    source /usr/share/git/completion/git-prompt.sh
    git_ps1_showdirtystate=auto
    git_ps1_showstashstate=auto
    git_ps1_showuntrackedfiles=auto
    git_ps1_showupstream=verbose
    git_ps1_showcolorhints=auto
    git_ps1_compresssparsestate=auto
    git_ps1_describe_style=tag
    git=$(__git_ps1 " [%s]") || true
    fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m$git\033[0m"
    lf -remote "send $id set promptfmt \"$fmt\""
}}

cmd select-files ${{
    { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type f; } |
        if [ "$lf_hidden" = "false" ]; then
          # remove any hidden files so you only select files you can see.
          grep -v '/\.[^/]\+$'
        else
          cat
        fi |
        sed '/^$/d' | sort | uniq -u |
        xargs -d '\n' -r -I{} lf -remote "send $id toggle {}"
}}

cmd select-dirs ${{
    { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type d; } |
        if [ "$lf_hidden" = "false" ]; then
          grep -v '/\.[^/]\+$'
        else
          cat
        fi |
        sed '/^$/d' | sort | uniq -u |
        xargs -d '\n' -r -I{} lf -remote "send $id toggle {}"
}}

cmd trash %set -f; trash-put $fx

cmd yank-dirname $dirname -- "$f" | head -c-1 | xclip -i -selection clipboard
cmd yank-path $printf '%s' "$fx" | xclip -i -selection clipboard
cmd yank-basename $basename -a -- $fx | head -c-1 | xclip -i -selection clipboard
cmd yank-basename-without-extension ${{
    echo "$fx" |
      xargs -r -d '\n' basename -a |
      awk -e '{
        for (i=length($0); i > 0; i--) {
          if (substr($0, i, 1) == ".") {
            if (i == 1) print $0
            else print substr($0, 0, i-1)
            break
          }
        }
        if (i == 0)
          print $0
      }' |
      if [ -n "$fs" ]; then cat; else tr -d '\n'; fi |
      xclip -i -selection clipboard
}}

map <delete> trash
map <enter> shell

#map C copyto
map D delete
map E extract
map H set hidden!
#map M moveto
map P :link
map R bulkrename
map T trash

map o &open $f
map x $$f
map X !$f

map <f-2> rename
map <f-3> search

#map <c-h> set hidden!
map <c-n> push :mkdir<space>
#map <c-t> push %date<enter>
map <c-z> $ kill -STOP $PPID

on-cd

