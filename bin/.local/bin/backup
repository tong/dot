#!/bin/bash
set -euo pipefail

###############################################################################
# Backup Script
#
# Features:
#   - Creates dated snapshot directories using rsync with --link-dest.
#   - Supports local and remote destinations (over SSH).
#   - Maintains a "master" destination as the source of truth for all syncs.
#   - Rotates old backups per destination according to configured retention.
#   - Uses excludes to skip unnecessary files (cache, tmp, etc).
#   - Provides notifications via `notify-send` if available.
#
# Usage:
#   backup [-c|--config <config_file>] [-h|--help]
#
# Default config location:
#   ${XDG_CONFIG_HOME:-$HOME/.config}/backup/config
#
# Example config file:
#
#   # An array of all final destinations for the backup.
#   # Each entry is "<path> <days_to_keep>".
#   # The first entry is the MASTER_DEST.
#   DESTINATIONS=(
#     "/mnt/data/bak 30"
#     "pi:/mnt/hd4/bak 30"
#   )
#
#   # An array of source directories on your main computer to be backed up.
#   SOURCE_DIRS=(
#     "$HOME/dev"
#     "$HOME/something"
#   )
#
#   # An array of rsync exclude patterns.
#   EXCLUDE_PATTERNS=(
#     ".cache"
#     "node_modules"
#     "*.tmp"
#     "$HOME/.config/chromium"
#     "$HOME/.config/go"
#   )
#
###############################################################################

# --- Static Settings ---
readonly APP_NAME="backup"
readonly LOG_FILE="/tmp/${APP_NAME}.log"
readonly LOCK_FILE="/tmp/${APP_NAME}.lock"

# --- Global Config Vars (loaded from file) ---
# Declared here for global scope and populated by load_config()
MASTER_DEST=""
DESTINATIONS=()
SOURCE_DIRS=()
EXCLUDE_PATTERNS=()

# --- Helper Functions ---

usage() {
  cat <<EOF
Usage: $(basename "$0") [-c|--config config_file] [-h|--help]

Options:
  -c, --config <path>     Specify a custom configuration file.
                          Default: ${XDG_CONFIG_HOME:-$HOME/.config}/backup/config
  -h, --help              Display this help message.
EOF
}

log() {
  echo "$(date +"%Y-%m-%d %H:%M:%S") - $1" | tee -a "$LOG_FILE"
}

die() {
  log "ERROR: $1"
  notify-send -u critical -a "$APP_NAME" "Backup Failed" "$1"
  exit 1
}

acquire_lock() {
  if [ -e "$LOCK_FILE" ]; then
    local pid
    pid=$(cat "$LOCK_FILE")
    if ps -p "$pid" >/dev/null; then
      die "Lock file exists and process $pid is running. Aborting."
    else
      log "Stale lock file found for PID $pid. Removing."
    fi
  fi
  echo $$ >"$LOCK_FILE"
}

cleanup() {
  rm -f "$LOCK_FILE"
}

# --- Core Logic Functions ---

load_config() {
  local config_file="$1"
  if [[ ! -f "$config_file" ]]; then
    die "Config file not found. Please create it at: $config_file"
  fi

  # Source the config file to load the variables
  # shellcheck source=/dev/null
  source "$config_file"

  # Validate that required variables were loaded
  if ((${#DESTINATIONS[@]} == 0)); then
    die "DESTINATIONS array is empty in $config_file. At least one destination (the master) is required."
  fi

  # The master destination is the path from the FIRST entry in the array.
  read -r MASTER_DEST _ <<<"${DESTINATIONS[0]}"

  if [[ -z "$MASTER_DEST" || ${#SOURCE_DIRS[@]} -eq 0 ]]; then
    die "Required variables MASTER_DEST (from DESTINATIONS) or SOURCE_DIRS are not set in $config_file"
  fi
}

create_master_backup() {
  log "--- (1/3) Creating/updating master backup at $MASTER_DEST ---"
  mkdir -p "$MASTER_DEST" || die "Could not create master destination directory: $MASTER_DEST"

  if [ ! -w "$MASTER_DEST" ]; then
    die "Master destination '$MASTER_DEST' is not writable."
  fi

  local date
  date=$(date +"%Y-%m-%d")
  local destdir_local="$MASTER_DEST/$date"

  mkdir -p "$destdir_local"

  local latest_backup
  latest_backup=$(find "$MASTER_DEST" -mindepth 1 -maxdepth 1 -type d -not -name "$date" | sort -r | head -n 1)

  local link_dest_arr=()
  if [ -d "$latest_backup" ]; then
    link_dest_arr=("--link-dest=$latest_backup")
    log "Using $latest_backup for hard links."
  else
    log "No previous backup found to link against. Performing full backup."
  fi

  local rsync_excludes=()
  for ex in "${EXCLUDE_PATTERNS[@]}"; do
    rsync_excludes+=(--exclude="$ex")
  done

  log "Backing up all source directories to master destination..."
  if ! rsync -aR --delete "${rsync_excludes[@]}" "${link_dest_arr[@]}" "${SOURCE_DIRS[@]}" "$destdir_local/"; then
    die "Failed to create master backup. rsync command failed."
  fi
}

sync_to_destinations() {
  log "--- (2/3) Syncing master backup to secondary destinations ---"
  # Get all destinations except the first one (the master)
  local sync_dests=("${DESTINATIONS[@]:1}")

  if ((${#sync_dests[@]} == 0)); then
    log "No sync destinations configured. Skipping."
    return
  fi

  local date
  date=$(date +"%Y-%m-%d")
  local master_backup_path="$MASTER_DEST/$date"

  if [[ ! -d "$master_backup_path" ]]; then
    die "Master backup for today not found at $master_backup_path. Cannot sync."
  fi

  local all_sync_ok=true
  for dest_info in "${sync_dests[@]}"; do
    local dest_path
    read -r dest_path _ <<<"$dest_info"

    log "Syncing to destination: $dest_path"

    if [[ "$dest_path" == *":"* ]]; then
      local remote_host="${dest_path%%:*}"
      local remote_dir="${dest_path#*:}"
      local remote_cmd
      printf -v remote_cmd 'mkdir -p %q' "$remote_dir"
      # shellcheck disable=SC2029
      if ! ssh "$remote_host" "$remote_cmd"; then
        log "Warning: Could not create remote directory for $dest_path. Skipping sync."
        all_sync_ok=false
        continue
      fi
    fi

    if ! rsync -az --delete "$master_backup_path/" "$dest_path/$date/"; then
      log "Warning: Failed to sync to destination $dest_path"
      all_sync_ok=false
    fi
  done

  if ! $all_sync_ok; then
    log "Warning: One or more sync destinations failed."
  fi
}

rotate_destinations() {
  log "--- (3/3) Rotating backups for all destinations ---"
  for dest_info in "${DESTINATIONS[@]}"; do
    local dest_path
    local keep_days
    read -r dest_path keep_days <<<"$dest_info"

    if ! [[ "$keep_days" =~ ^[0-9]+$ ]]; then
      log "Warning: Invalid or missing keep_days for '$dest_path'. Skipping rotation."
      continue
    fi

    log "Rotating destination: $dest_path (keeping $keep_days days)"
    if [[ "$dest_path" == *":"* ]]; then
      # Remote Destination
      local remote_host="${dest_path%%:*}"
      local remote_dir="${dest_path#*:}"

      local remote_mkdir_cmd
      printf -v remote_mkdir_cmd 'mkdir -p %q' "$remote_dir"
      # shellcheck disable=SC2029
      if ! ssh "$remote_host" "$remote_mkdir_cmd"; then
        log "Warning: Could not create or access remote directory for $dest_path. Skipping rotation."
        continue
      fi

      local remote_find_cmd
      printf -v remote_find_cmd 'find %q -mindepth 1 -maxdepth 1 -type d -mtime +%s -exec rm -rf {} +' "$remote_dir" "$keep_days"
      # shellcheck disable=SC2029
      if ! ssh "$remote_host" "$remote_find_cmd"; then
        log "Warning: Failed to rotate remote backup at $dest_path"
      fi
    else
      # Local Destination
      if ! find "$dest_path" -mindepth 1 -maxdepth 1 -type d -mtime +"$keep_days" -exec rm -rf {} +; then
        log "Warning: Failed to rotate local backup at $dest_path"
      fi
    fi
  done
}

main() {
  # Set default config file path
  local config_file="${XDG_CONFIG_HOME:-$HOME/.config}/backup/config"

  # Manual argument parsing loop to support long options
  while [[ $# -gt 0 ]]; do
    case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    -c | --config)
      if [[ -n "$2" ]]; then
        config_file="$2"
        shift # shift past option argument
      else
        die "Error: --config requires a non-empty option argument."
      fi
      ;;
    --config=*)
      config_file="${1#*=}"
      ;;
    *)
      # Unknown option
      echo "Unknown option: $1"
      usage
      exit 1
      ;;
    esac
    shift # shift past option name
  done

  trap cleanup EXIT
  acquire_lock
  load_config "$config_file"

  notify-send -u normal -a "$APP_NAME" "Backup" "Backup startedâ€¦"
  log "--- Backup process started ---"

  local start_time
  start_time=$(date +%s)

  create_master_backup
  sync_to_destinations
  rotate_destinations

  local end_time elapsed
  end_time=$(date +%s)
  elapsed=$((end_time - start_time))

  log "--- Backup process complete in ${elapsed}s ---"
  notify-send -u normal -a "$APP_NAME" "Backup Finished" "Process completed in ${elapsed}s."
}

main "$@"
