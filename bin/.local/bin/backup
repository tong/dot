#!/bin/bash
set -euo pipefail

###############################################################################
# Backup Script
#
# Features:
#   - Creates dated snapshot directories using rsync with --link-dest.
#   - Supports local and remote destinations (over SSH).
#   - Maintains a "master" destination as the source of truth for all syncs.
#   - Rotates old backups per destination according to configured retention.
#   - Uses excludes to skip unnecessary files (cache, tmp, etc).
#   - Provides notifications via `notify-send` if available.
#
# Usage:
#   backup [-c|--config <config_file>] [-h|--help]
#
# Default config location:
#   ${XDG_CONFIG_HOME:-$HOME/.config}/backup/config
#
# Example config file:
#
#   # DESTINATIONS entries have the form: "<path> <days_to_keep>"
#   # The first entry is the MASTER_DEST.
#   DESTINATIONS=(
#     "/mnt/data/bak 10"
#     "pi:/mnt/hd4/bak 30"
#   )
#
#   # Directories to back up
#   SOURCE_DIRS=(
#     "$HOME/dev"
#     "$HOME/something"
#   )
#
#   # rsync exclude patterns
#   EXCLUDE_PATTERNS=(
#     ".cache"
#     "node_modules"
#     "*.tmp"
#     "$HOME/.config/chromium"
#     "$HOME/.config/go"
#   )
#
###############################################################################

readonly APP_NAME="backup"
readonly LOG_FILE="/tmp/${APP_NAME}.log"
readonly LOCK_FILE="/tmp/${APP_NAME}.lock"

MASTER_DEST=""
DESTINATIONS=()
SOURCE_DIRS=()
EXCLUDE_PATTERNS=()

usage() {
  cat <<EOF
Usage: $(basename "$0") [-c|--config config_file] [-h|--help]

Options:
  -c, --config <path>     Specify a custom configuration file.
                          Default: ${XDG_CONFIG_HOME:-$HOME/.config}/backup/config
  -h, --help              Display this help message.
EOF
}

log() {
  echo "$(date +"%Y-%m-%d %H:%M:%S") - $1" | tee -a "$LOG_FILE"
}

die() {
  log "ERROR: $1"
  notify-send -u critical -a "$APP_NAME" "Backup Failed" "$1" || true
  exit 1
}

acquire_lock() {
  if [ -e "$LOCK_FILE" ]; then
    local pid
    pid=$(cat "$LOCK_FILE")
    if ps -p "$pid" >/dev/null; then
      die "Lock file exists and process $pid is running. Aborting."
    else
      log "Stale lock file found for PID $pid. Removing."
    fi
  fi
  echo $$ >"$LOCK_FILE"
}

cleanup() {
  rm -f "$LOCK_FILE"
}

# --- Config ---

load_config() {
  local config_file="$1"
  if [[ ! -f "$config_file" ]]; then
    die "Config file not found. Please create it at: $config_file"
  fi

  # shellcheck source=/dev/null
  source "$config_file"

  if ((${#DESTINATIONS[@]} == 0)); then
    die "DESTINATIONS array is empty in $config_file. At least one destination (the master) is required."
  fi

  # First destination entry is master
  read -r MASTER_DEST _ <<<"${DESTINATIONS[0]}"

  if [[ -z "$MASTER_DEST" || ${#SOURCE_DIRS[@]} -eq 0 ]]; then
    die "Required variables MASTER_DEST (from DESTINATIONS) or SOURCE_DIRS are not set in $config_file"
  fi
}

# --- Backup creation ---

create_master_backup() {
  log "--- (1/3) Creating/updating master backup at $MASTER_DEST ---"
  mkdir -p "$MASTER_DEST" || die "Could not create master destination directory: $MASTER_DEST"

  if [ ! -w "$MASTER_DEST" ]; then
    die "Master destination '$MASTER_DEST' is not writable."
  fi

  local date
  date=$(date +"%Y-%m-%d")
  local destdir_local="$MASTER_DEST/$date"

  mkdir -p "$destdir_local"

  # Find last successful backup (with .ok marker)
  local latest_backup
  latest_backup=$(find "$MASTER_DEST" -mindepth 1 -maxdepth 1 -type d -name '20*' \
    -exec test -f "{}/.ok" \; -print | sort -r | head -n 1)

  local link_dest_arr=()
  if [ -n "$latest_backup" ] && [ -d "$latest_backup" ]; then
    link_dest_arr=("--link-dest=$latest_backup")
    log "Using $latest_backup for hard links."
  else
    log "No valid previous .ok backup found. Performing full backup."
  fi

  local rsync_excludes=()
  for ex in "${EXCLUDE_PATTERNS[@]}"; do
    rsync_excludes+=(--exclude="$ex")
  done

  log "Backing up all source directories to master destination..."
  if rsync -aR --delete "${rsync_excludes[@]}" "${link_dest_arr[@]}" "${SOURCE_DIRS[@]}" "$destdir_local/"; then
    touch "$destdir_local/.ok"
    log "Master backup completed successfully. Marked with .ok"
  else
    die "Failed to create master backup. rsync command failed."
  fi
}

# --- Sync secondary destinations ---

sync_to_destinations() {
  log "--- (2/3) Syncing master backup to secondary destinations ---"
  local sync_dests=("${DESTINATIONS[@]:1}")

  if ((${#sync_dests[@]} == 0)); then
    log "No sync destinations configured. Skipping."
    return
  fi

  local date
  date=$(date +"%Y-%m-%d")
  local master_backup_path="$MASTER_DEST/$date"

  if [[ ! -d "$master_backup_path" ]]; then
    die "Master backup for today not found at $master_backup_path. Cannot sync."
  fi

  local all_sync_ok=true
  for dest_info in "${sync_dests[@]}"; do
    local dest_path keep_days
    read -r dest_path keep_days <<<"$dest_info"

    log "Syncing to destination: $dest_path"
    if [[ "$dest_path" == *":"* ]]; then
      local remote_host="${dest_path%%:*}"
      local remote_dir="${dest_path#*:}"
      local remote_cmd
      printf -v remote_cmd 'mkdir -p %q' "$remote_dir"
      # shellcheck disable=SC2029
      if ! ssh "$remote_host" "$remote_cmd"; then
        log "Warning: Could not create remote directory for $dest_path. Skipping sync."
        all_sync_ok=false
        continue
      fi
    fi

    if ! rsync -az --delete "$master_backup_path/" "$dest_path/$date/"; then
      log "Warning: Failed to sync to destination $dest_path"
      all_sync_ok=false
    fi
  done

  if ! $all_sync_ok; then
    log "Warning: One or more sync destinations failed."
  fi
}

# --- Rotation logic ---

rotate_destinations() {
  log "--- (3/3) Rotating backups for all destinations ---"
  for dest_info in "${DESTINATIONS[@]}"; do
    local dest_path keep_days
    read -r dest_path keep_days <<<"$dest_info"

    if ! [[ "$keep_days" =~ ^[0-9]+$ ]]; then
      log "Warning: Invalid keep_days for '$dest_path'. Skipping rotation."
      continue
    fi

    log "Rotating destination: $dest_path (keep $keep_days days)"

    local prune_cmd="find %q -mindepth 1 -maxdepth 1 -type d -mtime +$keep_days -exec rm -rf {} +"

    if [[ "$dest_path" == *":"* ]]; then
      local remote_host="${dest_path%%:*}"
      local remote_dir="${dest_path#*:}"
      local remote_mkdir_cmd
      printf -v remote_mkdir_cmd 'mkdir -p %q' "$remote_dir"
      # shellcheck disable=SC2029
      ssh "$remote_host" "$remote_mkdir_cmd" || {
        log "Warning: Cannot access $dest_path"
        continue
      }

      local remote_find_cmd
      printf -v remote_find_cmd "$prune_cmd" "$remote_dir"
      # shellcheck disable=SC2029
      ssh "$remote_host" "$remote_find_cmd" || log "Warning: Failed to rotate remote backup at $dest_path"
    else
      eval "$(printf "$prune_cmd" "$dest_path")" || log "Warning: Failed to rotate local backup at $dest_path"
    fi
  done
}

# --- Main ---

main() {
  local config_file="${XDG_CONFIG_HOME:-$HOME/.config}/backup/config"

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    -c | --config)
      if [[ -n "${2:-}" ]]; then
        config_file="$2"
        shift
      else
        die "Error: --config requires a path."
      fi
      ;;
    --config=*) config_file="${1#*=}" ;;
    *)
      echo "Unknown option: $1"
      usage
      exit 1
      ;;
    esac
    shift
  done

  trap cleanup EXIT
  acquire_lock
  load_config "$config_file"

  notify-send -u normal -a "$APP_NAME" "Backup" "Backup startedâ€¦" || true
  log "--- Backup process started ---"

  local start_time
  start_time=$(date +%s)

  create_master_backup
  sync_to_destinations
  rotate_destinations

  local end_time elapsed
  end_time=$(date +%s)
  elapsed=$((end_time - start_time))

  log "--- Backup process complete in ${elapsed}s ---"
  notify-send -u normal -a "$APP_NAME" "Backup Finished" "Completed in ${elapsed}s." || true
}

main "$@"
