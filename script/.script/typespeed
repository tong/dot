#!/usr/bin/env bash
# shellcheck disable=SC2016,SC2059

# cpm: characters per minute
# wpm: words per minute (1 word = 5 characters)

KEYBOARD_ID="16"
LAYOUT=qwerty
METRIC=wpm
FORMAT="%d"
INTERVAL='1'

while true; do
    case "$1" in
    --keyboard_id) KEYBOARD_ID="$2"; shift 2;;
    --interval) INTERVAL=$2; shift 2;;
    --cpm) METRIC="cpm"; shift;;
    --wpm) METRIC="wpm"; shift;;
    --metric) METRIC=$2; shift 2;;
    --format) FORMAT=$2; shift 2;;
    --layout) LAYOUT=$2; shift 2;;
    *) break;;
    esac
done

# If you have a keyboard layout that is not listed here yet, create a condition
# yourself. $3 is the key index. Use `xinput test "AT Translated Set 2 keyboard"`
# to see key codes in real time.
case "$LAYOUT" in
	qwerty) CONDITION='($3 >= 10 && $3 <= 19) || ($3 >= 24 && $3 <= 33) || ($3 >= 37 && $3 <= 53) || ($3 >= 52 && $3 <= 58)'; ;;
	azerty) CONDITION='($3 >= 10 && $3 <= 19) || ($3 >= 24 && $3 <= 33) || ($3 >= 37 && $3 <= 54) || ($3 >= 52 && $3 <= 57)'; ;;
	qwertz) CONDITION='($3 >= 10 && $3 <= 20) || ($3 >= 24 && $3 <= 34) || ($3 == 36) || ($3 >= 38 && $3 <= 48) || ($3 >= 52 && $3 <= 58)'; ;;
    dvorak) CONDITION='($3 >= 10 && $3 <= 19) || ($3 >= 27 && $3 <= 33) || ($3 >= 38 && $3 <= 47) || ($3 >= 53 && $3 <= 61)'; ;;
    dontcare) CONDITION='1'; ;; # Register all key presses, not only letters and numbers
	*) echo "Unsupported layout \"$LAYOUT\""; exit 1; ;;
esac

# Account for the fact we're not listening a whole minute
multiply_by=60
word_size=5
divide_by=$INTERVAL

case "$METRIC" in
	wpm) divide_by=$((divide_by * word_size)); ;;
	cpm) ;;
	*) echo "Unsupported metric \"$METRIC\""; exit 1; ;;
esac

typespeed_cache="$(mktemp -p '' typespeed_cache.XXXXX)"
trap 'rm "$typespeed_cache"' EXIT

# Write a dot to our cache for each key press
printf '' > "$typespeed_cache"
xinput test "$KEYBOARD_ID" | \
	stdbuf -o0 awk '$1 == "key" && $2 == "press" && ('"$CONDITION"') {printf "."}' >> "$typespeed_cache" &

while true; do
	# Ask the kernel how big the file is with the command `stat`. The number we
	# get is the file size in bytes, which equals the amount of dots the file
	# contains, and hence how much keys were pressed since the file was last
	# cleared.
	lines=$(stat --format %s "$typespeed_cache")
	# Truncate the cache file so that in the next iteration, we count only new keypresses
	printf '' > "$typespeed_cache"
	# The shell only does integer operations, so make sure to first multiply and then divide
	value=$((lines * multiply_by / divide_by))
	printf "$FORMAT\\n" "$value"
	sleep "$INTERVAL"
done
